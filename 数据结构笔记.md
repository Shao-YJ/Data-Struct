# 1.概论

# 2.线性表 List

## 2.1概念

逻辑结构特征：

## 2.2链表

### 2.3.2循环链表

定义：链表中最后一个结点的指针指向头结点——从链表中的任一结点出发均可访问到其它结点。

循环判断条件：L->next=L

操作：

1. 合并循环链表

   ```C++
   void circularMerge(LinkList& L, LinkList& R) {
   	LinkList p = L->next;
   	L->next = R->next->next;	//L的下一个节点为R的第二个节点
   	R->data = R->next->data;	//将R的第一个节点数据存到头指针中，释放第一个节点
   	free(R->next);
   	R->next = p;
   }
   ```

2. josepher问题

   ```C++
   void josephus(LinkList& L,int n, int k, int m) {
   	LinkList p=L,temp;
   	int i=0;
   	while (i < k) {
   		p = p->next;
   		i++;
   	}
   	for (int j = 0; j < n; j++) {
   		i = 0;
   		while (i < m-1)					//得到第m个数的前一个节点指针
   		{
   			p = p->next;
   			if (p != L)
   				i++;
   		}
   		if (p->next == L)
   			p = p->next;
   		cout << p->next->data << " ";
   		temp = p->next;
   		p->next = p->next->next;
   		free(temp);
   	}
   }
   ```

### 2.3.3双向链表

定义：链表的每个结点包含两个指针域，一个指向后继，一个指向前驱。

操作：

1. 初始化

   ```C++
   void initDList(DLinkList& L) {
   	L = (DLinkList)malloc(sizeof(DNode));
   	if (!L) {
   		cout << "init error";
   		return;
   	}
   	L->data = 0;
   	L->next = L;
   	L->front = L;
   }
   ```

2. 在双向链表L中的第i个元素之前插入一个数据元素e**。**  

   ```C++
   void insertDList(DLinkList& L,int n,int e) {
   	DLinkList p = L,t;
   	for (int i = 0; i < n; i++) {
   		p = p->next;
   		if (!p)
   			return;
   	}
   	initDList(t);
   	t->data = e;
   	t->front = p->front;
   	p->front->next = t;
   	t->next = p;
   	p->front = t;
   }
   ```

3. 删除第i个元素

   ```C++
   void deleteDList(DLinkList& L, int i) {
   	DLinkList p = L;
   	int k = 0;
   	while (p->next&&k<i)
   	{
   		p = p->next; k++;
   	}
   	p->front->next = p->next;
   	if (p->next)
   		p->next->front = p->front;
   	free(p);
   }
   ```

   

## 2.3栈和队列

定义：栈和队列都是限制在“**端点**”进行插入操作和删除操作的线性表。

| 操作位置i | **线性表**  | **栈**          | **队列**      |
| --------- | ----------- | --------------- | ------------- |
| **插入**  | i∈[1,  n+1] | **i=****n+1**   | **i=****n+1** |
| **删除**  | i∈[1,  n]   | **i****=****n** | **i****=1**   |

### 2.3.1栈

定义:栈是一种先进后出（LIFO）的线性表。

判断空条件：top=base

顺序栈操作：

1. 定义

   ```C++
   typedef struct Stack {
   	int* base;
   	int* top;
   	int stacksize;
   }Stack;
   ```

2. 初始化

   ```C++
   void initStack(Stack& S,int n) {
   	S.base = (int*)malloc(n*sizeof(int));
   	S.top = S.base;
   	S.stacksize = n;
   }				
   ```

3. 进栈

   ```C++
   void push(Stack& S, int e) {
   	if (S.top - S.base > S.stacksize)
   	{
   		int* new_Stack = (int*)realloc(S.base,2 * S.stacksize * sizeof(int));
   		if (!new_Stack)
   			return;
   		S.base = new_Stack;
   	}
   	*(S.top++) = e;
   }
   ```

4. 出栈

   ```C++
   int pop(Stack& S) {
   	if (S.top != S.base)
   		return *(--S.top);	//是先--
   	else return NULL;
   }
   ```

链栈操作：

1. 定义

   ```C++
   typedef struct SNode {
   	int data;
   	struct SNode* next;
   }SNode,*LinkStack;
   ```

2. 初始化

   ```C++
   void initLinkStack(LinkStack& L,int Data=NULL) {
   	L = (LinkStack)malloc(sizeof(SNode));
   	if (!L)
   		return;
   	L->data = Data;
   	L->next = NULL;
   }
   ```

3. 进栈

   ```C++
   void push(LinkStack& L, int e) {
   	LinkStack p;
   	initLinkStack(p, e);
   	p->next = L->next;
   	L->next = p;
   }
   ```

4. 出栈

   ```C++
   int pop(LinkStack& L) {
   	int n;
   	LinkStack p;
   	p = L->next;
   	n = p->data;
   	L->next = p->next;
   	free(p);
   	return n;
   }
   ```

在使用栈时应注意：

1. 栈在使用之前必须初始化。
2. 顺序栈的大小——栈太小容易溢出，栈太大浪费空间。
3. 空栈问题。空栈常常是解决问题的起点，同时又是解决问题的终点。 

### 2.3.2队列

定义：队列是一种先进先出(FIFO)的线性表。

判定为空条件：当front=rear时，队列空。

顺序队列操作：

1. 定义

   ```C++
   typedef struct Queue {
   	int* front;
   	int* rear;
   	int size;
   }Queue;
   ```

2. 初始化

   ```C++
   void initQueue(Queue& Q,int n) {
   	Q.front = (int*)malloc(n * sizeof(int));
   	Q.rear = Q.front;
   	Q.size = n;
   }
   ```

3. 入队

   ```C++
   void inQueue(Queue& Q, int e) {
   	if (Q.rear - Q.front == Q.size) {
   		int* temp = (int*)realloc(Q.front, 2 * Q.size * sizeof(int));
   		if (!temp)
   			return;
   		Q.front = temp;
   		Q.rear = Q.front + Q.size;
   		Q.size += Q.size;
   	}
   	*(Q.rear++) = e;
   }
   ```

4. 出队

   ```C++
   int outQueue(Queue& Q) {
   	if (Q.rear != Q.front)
   		return *Q.front++;
   }
   ```

链队列操作：

1. 定义

   ```C++
   typedef struct QNode {
   	int data;
   	struct QNode* next;
   }QNode,*LinkQueue;
   ```

2. 初始化

   ```C++
   void initQueue(LinkQueue &L,int e) {
   	L = (LinkQueue)malloc(sizeof(QNode));
   	if (!L)
   		return;
   	L->data = e;
   	L->next = NULL;
   }
   ```

3. 入队（由于方便按先后顺序打印，将新入队的元素放在链表最后，会比较方便）

   ```C++
   void inQueue(LinkQueue& L,int e) {
   	LinkQueue p = L,t;
   	while (p->next)
   		p = p->next;
   	initQueue(t, e);
   	p->next = t;
   }
   ```

4. 出队

   ```C++
   int outQueue(LinkQueue& L) {
   	LinkQueue p = L->next;
   	int n = p->data;
   	L->next = p->next;
   	free(p);
   	return n;
   }
   ```

例题：

1. 输入10进制数n，输出d进制数。

   ```C++
   int _10toN(int e,int n) {
   	int p = 0;
   	Stack s;
   	initStack(s,10);
   
   	while (e) {
   		push(s, e % n);
   		e /= n;
   	}
   	while (!stackIsEmpty(s)) {
   		p = p * 10 + pop(s);
   	}
   	return p;
   }
   ```

   

2. 先产生n个[1，100]之间的随机整数，然后按照数的产生顺序依次配对输出奇数和偶数(即一次输出1个奇数和1个偶数)，直到奇数或者偶数输出完毕为止。

   ```C++
   void twoPair(int n) {
   	int i = 0;
   	int p;
   	Queue sin, dou;
   	initQueue(sin,100);
   	initQueue(dou, 100);
   
   	for (i = 0; i < n; i++) {
   		srand(i);
   		p = rand() % 100 + 1;
   		if (p % 2)
   			inQueue(sin, p);
   		else
   			inQueue(dou, p);
   	}
   	i = 1;
   	while (!queueIsEmpty(sin) && !queueIsEmpty(dou)) {
   		cout << "第" << i++ << "组:" << outQueue(sin) << " " << outQueue(dou) << endl;
   	}
   }
   ```


### 2.3.3循环队列

定义： 循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。 

判断条件：

- 空：rear=front
- 满：（rear+1)%MAXSIZE=front
- 根据以上判断条件可知，循环队列的最大元素个数为MAXSIZE-1，预留一个元素空间，用于处理队列“满”的情况。

操作：

1. 定义

   ```C++
   #define MAXSIZE 10
   typedef struct Squeue{
       int elem[MAXSIZE];
       int front;
       int rear;
   }Squeue;
   ```

2. 入队

   ```C++
   void inQueue(Squeue &S,int e) {
   	if (IsFull(S)) {
   		cout << "Queue is full!" << endl;
   		return;
   	}
   	S.elem[S.rear] = e;
   	S.rear = (S.rear + 1) % MAXSIZE;
   }
   ```

3. 出队

   ```C++
   int outQueue(Squeue& S) {
   	if (IsEmpty(S))
   		return NULL;
   	int n = S.elem[S.front];
   	S.front = (S.front + 1) % MAXSIZE;
   	return n;
   }
   ```

4. 打印

   ```C++
   void queueToString(Squeue S) {
   	int front = S.front;
   	int rear = S.rear;
   	while (front != rear) {
   		cout << S.elem[front] << " ";
   		front = (front + 1) % MAXSIZE;
   	}
   	cout << endl;
   }
   ```

例题：

1. 有两个进程同时存在于一个程序中。其中第一个进程在屏幕上连续显示字符“-”,与此同时，程序不断检测键盘是否有输入，如果有，就读入用户键入的字符并保存到输入缓冲区中。在用户输入时，键入的字符并不立即回显在屏幕上。当用户键入一个逗号(,)时，表示第一个进程结束，第二个进程从缓冲区中读取那些已键入的字符并显示在屏幕上。第二个进程结束后，程序又进入第一个进程，重新显示字符“-”,同时用户又可以继续键入字符，直到用户输入一个分号(;)键，才结束第一个进程，同时也结束整个程序。  

   ```C++
   void twoProgress() {
   	char ch;
   	Squeue s;
   	while (true) {
   		if (_kbhit()) {
   			ch = _getch();
   			if (ch == *",") {
   				while (!IsEmpty(s)) {
   					cout << (char)outQueue(s);
   				}
   				continue;
   			}
   			inQueue(s, ch);
   			if (ch == *";")
   				break;
   		}
   		Sleep(100);
   		cout << "-";
   	}
   }
   ```

2. 迷宫问题

   假设迷宫由m行n列构成，有一个入口(1, 1)和一个出口(m，n)。试找出一条从入口通往出口的可行路径(如输出可通行路径方格的坐标序列)。

   ```C++
   void labyrinth(int m,int n) {
       //结构体表示坐标的数据结构
   	typedef struct Site {	
   		int x;
   		int y;
   	public:
   		Site(int i, int j) {
   			x = i; y = j; 
   		}
   		Site() {
   			x = 0; y = 0;
   		}
   	}Site;
   
   	int i, j;//当前坐标位置
   
   	int Map[10][10] = { 0 };//地图，数值为0表示不能通行，1表示可以通行
   	for (i = 1; i < 9; i++)
   		for (j = 1; j < 9; j++)
   			Map[i][j] = 1;
   
   	Map[1][3] = 0;	Map[1][4] = 0;	Map[1][6] = 0;	Map[2][6] = 0;	Map[3][1] = 0;
   	Map[3][2] = 0;	Map[3][5] = 0;	Map[4][4] = 0;	Map[5][3] = 0;	Map[5][6] = 0;
   	Map[5][8] = 0;	Map[6][3] = 0;	Map[6][6] = 0;	Map[7][5] = 0;	Map[7][6] = 0;
   	Map[8][7] = 0;
   
       //输出地图
   	for (i = 0; i < 10; i++)
   	{
   		for (j = 0; j < 10; j++)
   			cout << Map[i][j] << " ";
   		cout << endl;
   	}
   
   	LinkStack<Site>  link;//用栈来存储上一个路过的节点坐标
   	i = 1, j = 1;
   	int k;
   	Site temp;
       
       //循环寻找路径，按照右下左上的顺序
   	while (i + j) {
   		k = 0;
   		if (i == m && j == n)k = 9;
   		else if (Map[i][j + 1]==1)k = 2;
   		else if (Map[i+1][j] == 1)k = 3;
   		else if (Map[i][j - 1] == 1)k = 4;
   		else if (Map[i-1][j] == 1)k = 5;
   		else if (i==1&&j==1)k = 6;
   		
           //如果当前节点存在除上一个节点之外还有其他节点，则将该节点加入栈，否则不加入。
           //如果直接增加可以前往的下一个节点，会导致有三个方向可通行的节点，在第一次回退之后从栈中pop出，但不会再push进去的结果。也就是丢失坐标。
   		switch (k) {
   		case 0:
   			Map[i][j] = -1;
   			temp = link.pop(); i = temp.x; j = temp.y;  break;
   		case 2:link.push(Site(i, j)); Map[i][j++] = 2; break;
   		case 3:link.push(Site(i, j)); Map[i++][j] = 2; break;
   		case 4:link.push(Site(i, j)); Map[i][j--] = 2; break;
   		case 5:link.push(Site(i, j)); Map[i--][j] = 2; break;
   		case 6:cout << "Search Failed" << endl; return;
   		case 9:link.push(Site(i, j));
   			cout << "Successful Serach,The Route is:" << endl; i = 0; j = 0; break;
   		}
   	}
   	temp = link.pop();
   	cout << "(" << temp.x << "," << temp.y << ")";
   	while (!link.isEmpty()) {
   		temp = link.pop();
   		cout << "<--(" << temp.x << "," << temp.y << ")";
   	}
   
   }	
   ```

3. 括号匹配算法

   设在表达式中允许包含[]和()两种括号，约定()  或[()]这类的括号匹配格式是正确的，
   而[(]) 或([()) 或(()]这类的括号匹配格式是不正确的。

   ```C++
   void bracketMatch() {
   	MList<char> p(100);
   	cin >> p;//在MList中重载运算符号>>
   	p.n = strlen(p.elem);
   	LinkStack<char> chstack;
   	char ch,temp;
   	int i, n = p.n;
   	for (i = 0; i < n; i++)
   	{
   		ch = p.elem[i];
   		if (ch == *"[" || ch == *"{"||ch==*"(")
   			chstack.push(ch);//左括号就进栈
   		if (ch == *"]" || ch == *"}" || ch == *")")
   		{
   			temp = chstack.pop();//右括号就从栈中pop出上一个左括号，如果匹配则合法
   			switch (temp) {
   			case * "[":if (ch == *"]")break;
   			case * "{":if (ch == *"}")break;
   			case * "(":if (ch == *")")break;
   			default:cout << "The expression is invalid." << endl; return;
   			}
   		}
   	}
       //如果右括号都匹配，但左括号比右括号多的情况，也不合法。
   	if (i == n && !chstack.isEmpty())
   	{
   		cout << "The expression is invalid." << endl;
   		return;
   	}
   	cout << "The bracket is match!" << endl;
   }
   ```

4. 算数表达式求解

   ```C++
   void arthimetic() {
   	MList<char> list(100);
   	LinkStack<char> stack;
   	Queue<char> queue;
   
   	cin >> list;
   	int n = strlen(list.elem);
   	int i = 0;
   	char ch,p;
   	while (i < n) {
   		ch = list.elem[i++];
   		if (ch >= 48 && ch <= 57) {
   			queue.push(ch);
   			continue;
   		}
   		else if (queue.top() >= 48 && queue.top() <= 57) {
   			queue.push(*" ");
   		}
   		if (ch == *"(") {
   			stack.push(ch);
   			continue;
   		}
   		if (ch == *"*" || ch == *"/") {
   			if (stack.isEmpty()){
   				stack.push(ch);
   				continue;
   			}
   			p = stack.top();
   			if (p == *"(" || p == *"+" || p == *"-")
   				stack.push(ch);
   			else
   			{
   				queue.push(stack.pop());
   				stack.push(ch);
   			}
   			continue;
   		}
   		if (ch == *"+" || ch == *"-") {
   			if (stack.isEmpty() || stack.top() == *"(")
   				stack.push(ch);
   			else {
   				while (!stack.isEmpty() && stack.top() != *"("){
   					queue.push(stack.pop());
   				}
   				stack.push(ch);
   			}
   			continue;
   		}
   		if (ch == *"#"&&i==n) {
   			while (!stack.isEmpty())
   				queue.push(stack.pop());
   			break;
   		}
   		else if(i==n){
   			cout << "The arthimetic is invalid!!!" << endl;
   			return;
   		}
   		while (ch == *")")
   		{
   			p = stack.pop();
   			if (p != *"(")
   				queue.push(p);
   			else
   				break;
   		}
   	}
   	queue.toString();
   
   	LinkStack<int> numStack;
   	while (!queue.isEmpty()) {
   		i = 0;
   		while (queue.head() >= 48 && queue.head() <= 57)
   		{
   			i = i * 10 + (int)(queue.pop()-48);
   		}
   		if (i) {
   			numStack.push(i);
   			continue;
   		}
   		ch = queue.pop();
   		int a = 0, b = 0,c=0;
   		switch (ch) {
   		case * " ":break;
   		case * "+":b = numStack.pop(); a = numStack.pop(); c = a + b; numStack.push(c); break;
   		case * "-":b = numStack.pop(); a = numStack.pop(); c = a - b; numStack.push(c); break;
   		case * "*":b = numStack.pop(); a = numStack.pop(); c = a * b; numStack.push(c); break;
   		case * "/":b = numStack.pop(); a = numStack.pop(); c = a / b; numStack.push(c); break;
   		default:cout << "No choice!" << endl; break;
   		}
   	}
   ```

5. haoni问题（递归）

   ```C++
   void move(char x, int n, char z)
   {
   	cout << "将" << x << "柱上的第" << n << "块移动到" << z << "柱上" << endl;
   }
   
   void hanoi(char x, int n, char y, char z) {
   	if (n == 1)
   		move(x, n, z);
   	else {
   		hanoi(x, n - 1, z, y);
   		move(x, n, z);
   		hanoi(y, n - 1, x, z);
   	}
   }
   ```

6. 背包问题

   设有n个物品，每个物品的重量为wi, i=1, 2, …, n。试从这n个物品中选取若干个，使其重量之和＝背包的容量T。

   ```C++
   bool Knapsack(int T, int n,int w[]) {
   	if (T == 0)return 1;
   	if (T < 0 || n < 1)return 0;
   	if (Knapsack(T - w[n - 1], n - 1, w)) {
   		cout << w[n - 1] << " "; return 1;
   	}
   	return Knapsack(T, n - 1,w);
   }
   
   void bag() {
   	int n = 7;
   	int w[7] = { 27,24,17,51,28,32,63, };
   	int T = 100;
   	Knapsack(T, n, w);
   }
   ```

7. 查找倒数第k个位置上的结点 

   ```C++
   LinkList LinkSearch(LinkList L, int k)
   {	k0=1; p=L->next, q=p;  //q为所查结点
   	while(p)
   	{	if(k0<=k) k0++;
   		else q=q->next;
   		p=p->next;
   	}
   	return q;
   } 
   ```

## 2.4串（不考）

## 2.5数组与广义表

### 2.5.1定义

​		数组是一组偶对(下标值，数据元素值)的集合。在数组中，对于一组有意义的下标，都存在一个与其对应的值。一维数组对应着一个下标值，二维数组对应着两个下标值，如此类推。

​		数组**是由n(n>1)个具有相同数据类型的数据元素a1，a2，…，an组成的有序序列，且该序列必须存储在一块地址连续的存储单元中。

- 数组中的数据元素具有相同数据类型。
- 数组是一种随机存取结构，给定一组下标，就可以访问与其对应的数据元素。
- 数组中的数据元素个数是固定的。

### 2.5.2数组的顺序表示和实现

​		数组一般不做插入和删除操作，也就是说，数组一旦建立，结构中的元素个数和元素间的关系就**不再发生变化**。因此，一般都是采用**顺序存储**的方法来表示数组。

​		问题：计算机的内存结构是**一维(线性)地址结构**，对于多维数组，将其存放(映射)到内存一维结构时，有个**次序约定问题**。即必须按某种次序将数组元素排成一列序列，然后将这个线性序列存放到内存中。

​		二维数组是最简单的多维数组，以此为例说明多维数组存放(映射)到内存一维结构时的次序约定问题。

**通常有两种顺序存储方式：**

1. 行优先顺序：将数组元素按行排列，第i+1个行向量紧接在第i个行向量后面。对二维数组，按行优先顺序存储的线性序列为：

   a11,a12,…,a1n, a21,a22,…a2n  ,……,  am1,am2,…,amn  

   PASCAL和C是按行优先顺序存储的。

2. 列优先顺序：将数组元素按列向量排列，第j+1个列向量紧接在第j个列向量之后，对二维数组，按列优先顺序存储的线性序列为：

   a11,a21,…,am1,   a12,a22,…am2,  ……,  an1,an2,…,anm

   FORTRAN是按列优先顺序存储的。

**地址计算公式**：

1. 以“行优先顺序”存储

   - 设有二维数组A=(aij)m×n，若每个元素占用的存储单元数为l(个)，LOC[a11]表示元素a11的首地址，即数组的首地址。

     二维数组中任一元素aij的(首)地址是：

     **LOC[aij]=LOC[a11]+[(i-1)n+(j-1)]×l** 

   - 对于三维数组A=(aijk)m×n×p，若每个元素占用的存储单元数为l(个)，LOC[a111]表示元素a111的首地址，即数组的首地址。以“行优先顺序”存储在内存中。

     三维数组中任一元素aijk的（首）地址是：

     **LOC[aijk]=LOC[a111]+[(i-1)×n×p+(j-1)×p+(k-1)]×l**

   - 推而广之，对n维数组A=(aj1j2…jn) ，若每个元素占用的存储单元数为l(个)，LOC[a11 …1]表示元素a11 …1的首地址。则 以“行优先顺序”存储在内存中。

     n维数组中任一元素aj1j2…jn的(首)地址是：

     **LOC[aj1j2…jn]=LOC[a11 …1]+[(j1-1) (b2×…×bn)+ (j2-1)×(b3×…×bn) + … + (j(n-1)-1)bn+ (jn-1)]×l**         

2. 以“列优先顺序”存储

   - 和以上类似

### 2.5.3矩阵的压缩存储

对于高阶矩阵，若其中非零元素呈某种规律分布或者矩阵中有大量的零元素，若仍然用常规方法存储，可能存储重复的非零元素或零元素，将造成存储空间的大量浪费。对这类矩阵进行压缩存储：

- 多个相同的非零元素只分配一个存储空间；
- 零元素不分配空间。

### 2.5.3.1特殊矩阵

特殊矩阵：是指非零元素或零元素的分布有一定规律的矩阵。

1. **对称矩阵**：

   - 一个n阶方阵A=(aij)n×n中的元素满足性质：aij=aji  1≦i,j≦n且i≠j
   - 元素关于主对角线对称，让每一对**对称元素**aij和aji(i≠j)分配一个存储空间，则n×n个元素压缩存储到n(n+1)/2个存储空间，能节约近一半的存储空间。
   - **规定**：按照“**行优先顺序**”存储**下三角形**中的元素
   - 设用一维数组(向量)sa[n(n+1)/2]存储n阶对称矩阵。为了便于访问，必须找出矩阵A中的元素的下标值（i,j）和向量sa[k]的下标值k之间的对应关系。  
   - 若i>=j，在下三角形中，前i-1行中共有1+2+...+(i-1)=i×(i-1)/2个元素，k=i×(i-1)/2+j-1；若i<j,在上三角形中，k=j×(j-1)/2+i-1。
   - 称**sa**[n×(n+1)/2]为n阶对称矩阵A的**压缩矩阵**

2. **三角矩阵**：

   - 三角矩阵分为上三角矩阵和下三角矩阵
   - 三角矩阵中的重复元素c可共享一个存储空间，其余的元素正好有n(n+1)/2个，因此，三角矩阵可压缩存储到向量sa[0…n(n+1)/2]中，其中c存放在向量的第n(n+1)/2个分量中。
   - 下三角矩阵：k=i×(i-1)/2+j-1，i>=j;k=n×(n-1)/2,i<j
   - 上三角矩阵：k=(2n-i+2)×(i-1)/2+j-i,i<j;k=

3. **对角矩阵**：

   - 非零元素仅出现在主对角上，主对角线上的那条对角线，主对角线下的那条对角线上。
   - 元素个数为3n-2，存在一维矩阵sa[3n-2]中
   - 一个k对角矩阵(k为奇数)A是满足下述条件： 当|i-j|>(k-1)/2时， aij=0
   - 以**三对角矩阵**为例讨论：对于aij，在前面有i-1行元素，其中第一行只有两个元素，故共有3i-4个元素；在第i行里，是第j-i+2个元素，由于sa是从0开始计数，故aij下标k=3i-4+j-i+2-1=2i+j-3
   - 称**sa**[3n-2]为n阶对称矩阵A的**压缩矩阵**

4. **稀疏矩阵**

   - 对于稀疏矩阵，目前还没有一个确切的定义。设矩阵A是一个n×m的矩阵中有s个非零元素，设 δ=s/(n×m)，称δ为稀疏因子，如果某一矩阵的稀疏因子δ满足δ≦0.05时称为稀疏矩阵。

   - 对于稀疏矩阵，采用压缩存储方法时，**只存储非0元素**。必须存储非0元素的行下标值、列下标值、元素值。因此，一个**三元组**(i, j, aij)唯一确定稀疏矩阵的一个非零元素。

   - 例如：((1,2,12),(1,3,9),(3,1,-3),(3,8,4),(4,3,24),(5,2,18),(6,7,-7),(7,4,-6))

   - 十字链表：

     ![1664510393769](F:\ProgramData\自动缓存文件\TyporaCache\1664510393769.png)

     ![1664510433486](F:\ProgramData\自动缓存文件\TyporaCache\1664510433486.png)

     - ```C++
       typedef struct Clnode
       {
       	int row, col;   /*  行号和列号  */
       	int value;    /*  元素值  */
       	struct Clnode* down, * right;
       }OLNode;//非零结点
       
       typedef struct
       {
       	int rn;        /*  矩阵的行数  */
       	int cn;        /*  矩阵的列数  */
       	int tn;        /*  非0元素总数  */
       	OLNode* rhead;
       	OLNode* chead;
       } CrossList;//头结点
       ```

## 2.5.4广义表

广义表是线性表的推广和扩充，在人工智能领域中应用十分广泛。

线性表是n(n≧0 )个元素a1, a2 ,…, an的有穷序列，该序列中的所有元素具有相同的数据类型且只能是原子项(Atom)。**所谓原子项可以是一个数或一个结构，是指结构上不可再分的。**若**放松对元素的这种限制**，容许它们具有其自身结构，就产生了广义表的概念。

 广义表(Lists，又称为列表 )：是由n(n ≧0)个元素组成的有穷序列： LS=(a1，a2，…，an)。其中**ai或者是原子项，或者是一个广义表**。LS是广义表的名字，n为它的长度。若ai是广义表，则称为LS的子表。

习惯上：原子用小写字母，子表用大写字母。

若广义表LS非空时：

- a1(表中第一个元素)称为表头；
- **其余元素组成的子表**称为**表尾**：(a2，a3，…，an)
- 广义表中所包含的元素(包括原子和子表)的个数称为表的长度。
- 广义表中括号的最大层数称为表深 (度)。

![1664511692511](F:\ProgramData\自动缓存文件\TyporaCache\1664511692511.png)

**重要结论：**

⑴ 广义表的元素可以是原子，也可以是子表，子表的元素又可以是原子，又可以是子表， …。即广义表是一个多层次的结构。（表2中的广义表D的图形表示如图5-12所示。E是一个深度为无穷的元素，其实际表示就是E=(a,(a,(a,(a,...))))，是一个无限嵌套的元素。）

(2) 广义表可以被其它广义表所共享，也可以共享其它广义表。广义表共享其它广义表时通过表名引用。

(3) 广义表本身可以是一个递归表。

(4) 根据对表头、表尾的定义，任何一个非空广义表的表头可以是原子，也可以是子表， 而表尾必定是广义表。

**存储结构**：

第一种存储结构：

由于广义表中的数据元素具有不同的结构，通常用链式存储结构表示，每个数据元素用一个结点表示。因此，广义表中就有两类结点：

- 一类是**表结点**，用来表示**广义表项**，由**标志域**，**表头指针域**，**表尾指针域**组成;
- 另一类是**原子结点**，用来表示**原子项**，由**标志域**，原子的**值域**组成。如图5-13所示。

![1664592098354](F:\ProgramData\自动缓存文件\TyporaCache\1664592098354.png)

结构定义

```C++
typedef struct GLNode
{
	int tag; /*  标志域，为1：表结点;为0 ：原子结点  */
	union
	{
		elemtype value;     /* 原子结点的值域  */
		struct
		{
			struct GLNode* hp, * tp;
		}ptr;   /*  ptr和atom两成员共用  */
	}Gdata;
} GLNode;      /* 广义表结点类型  */

```

**例：** 对A=()，B=(e)，C=(a, (b, c, d) )，D=(A, B, C)，E=(a, E)的广义表的存储结构如图所示。

![1664595434828](F:\ProgramData\自动缓存文件\TyporaCache\1664595434828.png)

**对于上述存储结构，有如下几个特点：**

(1) 若广义表为空，表头指针为空；否则，表头指针总是指向一个表结点，其中hp指向广义表的表头结点(或为原子结点，或为表结点) ，tp指向广义表的表尾(表尾为空时，指针为空，否则必为表结点)。

(2) 这种结构求广义表的长度、深度、表头、表尾的操作十分方便。

(3) 表结点太多，造成空间浪费。也可用以下所示的结点结构。

![1664595691141](F:\ProgramData\自动缓存文件\TyporaCache\1664595691141.png)

结构定义

```C++
template<class T>
class GLNode {
public:
	GLNode(int type, T value);
	GLNode(int type,GLNode *value)
private:
	int tag;/*  标志域，为1：表结点;为0 ：原子结点  */
	union {
		T value;
		GLNode* hp;
	}data;
	GLNode* tp;
};/* 广义表结点类型  */

template<class T>
inline GLNode<T>::GLNode(int type, T value)
{
	this->tag = type;
	this->data = value;
	this->tp = NULL;
}

template<class T>
inline GLNode<T>::GLNode(int type, GLNode* value) {
	this->tag = type;
	this->data = value;
	this->tp = NULL;
}
```

**例：** 对A=()，B=(e)，C=(a, (b, c, d) )，D=(A, B, C)，E=(a, E)的广义表的存储结构如图所示。

存储结构：

![1664595224039](F:\ProgramData\自动缓存文件\TyporaCache\1664595224039.png)

# 3.树 Tree

## 3.1基本概念

**定义**：n个结点的有限集合(n≥0)；空树：n=0的树(Tree)

1. 对于非空树(n>0时)，**有且只有**1个根结点;

   ——根结点：没有前驱的结点

2. 当n>1时，除根结点之外，树中的其它任意1个结点**有且只有**1个前驱；

3. 树中每个结点可以有m个后继(m≥0)。

**树的递归定义：**

![1664675525197](F:\ProgramData\自动缓存文件\TyporaCache\1664675525197.png)

**树的结点：**包含一个数据元素和若干个指针(这些指针指向其拥有子树的根)

**结点的度：**结点拥有子树的个数

**叶子结点：**度=0的结点

**分支节点：**度>0的结点

**树的度：**max(结点的度)

**结点的孩子：**

**结点的孩子：**该结点的指针指向的结点——结点拥有的(某棵)子树的根。

**孩子的双亲：**孩子结点的前驱(结点)。

**兄弟结点：**同一个双亲结点的孩子。例如，在树A(B，C，D)中，结点C是结点B (或D)的兄弟结点。

**结点的层次：**根结点定义为第1层；根结点的孩子定义为第2层；第i层结点的孩子定义为第i+1层。

**树的高度(或深度)** =max(结点的层次)。例如树A(B(E(M, N), F), C(G, H(P), I), D(J, K))的高度= 4。**树的高度 ≠ 树的度**(不同概念)。

**有序树：**(树中每一个)结点的各棵子树按一定的次序从左向右排列的树。

**无序树**：结点各子树与次序无关的树。

例如，对于有序树：A(B, C)≠A(C, B)，对于无序树：A(B, C) = A(C, B)。

森林：m棵互不相交的树的有限集， 即F={ T1, T2, …, Tm }，m≥0。当m=0时，称为空森林。对于森林，如果将每棵树都赋予同一个双亲结点R，即F=R(T1, …, Tm)，则森林成为一棵树。

## 3.2二叉树

定义：结点的度<=2的(有序)树——二叉树中每个结点的子树最多2棵。

二叉树的5中基本形态：

![1664677640446](F:\ProgramData\自动缓存文件\TyporaCache\1664677640446.png)

**满二叉树**：一棵高度为k且具有2^k-1个结点的二叉树，例如下图是k=4的满二叉树。

![1664677738095](F:\ProgramData\自动缓存文件\TyporaCache\1664677738095.png)

**完全二叉树**：一棵高度为k、结点个数∈[2^(k-1),2^k-1]，且第k层的结点都集中在左侧的二叉树。(满二叉树也是完全二叉树)。

![1664678239251](F:\ProgramData\自动缓存文件\TyporaCache\1664678239251.png)

**二叉树的性质**：

1. 在二叉树的第i层上最多有2^(i-1)个结点（i>=1)

2. 高度为k的二叉树最多有2^k-1个结点(k>=1)

3. 如果二叉树T的叶子结点数为n0，度为2的结点数为n2，则n0=n2+1

   证明：设二叉树T共有n个结点，叶子结点数为n0，度=1的结点数为n1，度=2的结点数为n2，T的分支数为m。

   有n=n0+n1+n2;m=n-1=n1+n2×2;

   即n0+n1+n2-1=n1+n2×2  =>n0=n2+1

4. ![1664678871171](F:\ProgramData\自动缓存文件\TyporaCache\1664678871171.png)

5. 设**完全二叉树**含有n个结点。

   1. 如果编号i=1，则结点i是根节点；如果编号i>1，则结点i的双亲结点的编号是(i/2)的向下取整
   2. 结点i的左孩子的编号是2i；结点i的右孩子的编号是2i+1![1664679099093](F:\ProgramData\自动缓存文件\TyporaCache\1664679099093.png)
   3. 如果2i<n，则结点i为分支结点；如果2i>n，则结点i为叶子结点。
   4. 如果n为奇数，则每个**分支结点**都有左孩子和右孩子，如果n为偶数，则编号为n/2的分支结点只有左孩子，没有右孩子。

**二叉树的存储结构**

二叉树的**顺序存储结构**：

- 将二叉树的所有结点按照一定的次序存放到一组地址连续的存储单元中。（一般从根节点开始，自上而下，自左到右排成一个线性序列）

![1664680612403](F:\ProgramData\自动缓存文件\TyporaCache\1664680612403.png)

- 将结点的编号和数组下标一一对应；结点的编号必须能反映其逻辑关系。
- 顺序存储结构适用于**完全二叉树**——结点的编号容易和数组下标对应，且浪费的存储空间较小。

二叉树的**链式存储结构**

操作：

1. 初始化

   ```C++
   template<class T>
   class BTree {
   public:
   	T data;
   	BTree<T>* lc;
   	BTree<T>* rc;
   
   	BTree() { this->lc = this->rc = NULL; };
   	BTree(T e);
   };
   
   template<class T>
   inline BTree<T>::BTree(T e){
   	this->data = e;
   	this->lc = this->rc = NULL;
   }
   ```

   

2. 根据树的字符形式来创建二叉树

   ```C++
   template<class T>
   void BTree<T>::create(string str,int &k)
   {
   	T ch = str[k];
   	while (ch) {
   		if (ch == '('&&str[k+1]==',')k+=2;
   		else if (ch == '(' || ch == ',' && str[k + 1] == ')')k++;
   		else if (ch == ')' || ch == ',') {
   			k++; return;
   		}
   		else{
   			BTree<T>* t = (BTree<T>*)malloc(sizeof(BTree<T>));
               //如果直接用构造函数初始化，地址不变，定义右孩子时左孩子也会变化
   			t->data = ch;
   			if (k != 0 && str[k - 1] == ',')this->rc = t;
   			else this->lc = t;
   			k++;
   			t->create(str, k);
   			ch = str[k];
   			continue;
   		}
   		ch = str[k];
   	}
   }
   ```

   

3. 打印树

   ```C++
   template<class T> //跳过头结点，进入根节点
   void BTree<T>::toString() {
   	this->lc->tostring();
   	cout << endl;
   }
   
   template<class T>
   void BTree<T>::tostring() {
   	if (!this)return;//是空子树则返回
   	cout << this->data ;
   	if (this->lc) {
   		cout << "(";
   		this->lc->tostring();
   	}
   	else {
   		if (this->rc)
   			cout << "(";
   		else return;
   	}
   	if (this->rc) {
   		cout << ",";
   		this->rc->tostring();
   		cout << ")";
   	}
   	else if(!this->rc){
   		cout <<")"; return;
   	}
   }
   ```

   

4. 求树的深度

   ```C++
   template<class T>
   int BTree<T>::depth() {
   	if (!this)return -1;
   	int ld = this->lc->depth();
   	int rd = this->rc->depth();
   	return ld > rd ? ld + 1 : rd + 1;
   }
   ```

## 3.3二叉树遍历

遍历二叉树：按照 一定规则访问二叉树中的每个结点，使得每个结点均能被访问一次，而且仅被访问一次。

通过一次遍历，可以使二叉树中的结点由**非线性排列**变为**线性排列**——**遍历操作可以使二叉树线性化。**

二叉树由3个基本单元组成：**根结点、左子树和右子树**，因此，遍历二叉树的问题可归结为解决三个子问题：

1. 访问根结点(D)；
2. 遍历左子树(L)；
3. 遍历右子树(R)。

常用的三种遍历顺序：DLR（先序）、LDR（中序）、LRD（后序）

- (DLR)先序遍历

  **若二叉树为空，则空操作；否则**

  1. 访问根结点；
2. 先序遍历左子树；
  3. 先序遍历右子树。

- (LDR)中序遍历

  1. 中序遍历左子树
  2. 访问根节点
  3. 中序遍历右子树

- (LRD)后序遍历

  1. 后续遍历左子树
  2. 后序遍历右子树
  3. 访问根节点

- 操作（递归遍历）：

  ```C++
  template<class T>//先序遍历
  void BTree<T>::preOrder() {
  	if (!this)return;
  	cout << this->data;
  	this->lc->preOrder();
  	this->rc->preOrder();
  }
  
  template<class T>//中序遍历
  void BTree<T>::inOrder() {
  	if (!this)return;
  	this->lc->inOrder();
  	cout << this->data;
  	this->rc->inOrder();
  }
  
  template<class T>//后序遍历
  void BTree<T>::postOrder() {
  	if (!this)return;
  	this->lc->postOrder();
  	this->rc->postOrder();
  	cout << this->data;
  }
  ```

**题目**:

1. 已知二叉树T的先序序列和中序序列分别为ABDFGCEH和BFDGACEH，试画出T。  

   ![1665023531075](F:\ProgramData\自动缓存文件\TyporaCache\1665023531075.png)

2. 设二叉树T的中序序列和后序序列分别为 (中序) 3, 7, 11, 14, 18, 22, 27, 35; (后序) 3, 11, 7, 14, 27, 35, 22, 18。试画出二叉树T。

   T = 18 ( 14 ( 7 ( 3, 11) ), 22 (, 35 ( 27 )))  

非递归遍历：

1. 先序

   ```C++
   template<class T>
   void preOrder(BTree<T> tree) {
   	LinkStack<BTree<T>*> tstack;
   	BTree<T>* p ;
   	tstack.push(tree.lc);
   	while (!tstack.isEmpty()) {
   		p = tstack.pop();
   		p->visit();
   		if (p->rc)//先将右节点放入栈中，弹出时就是在左节点后
   			tstack.push(p->rc);
   		if (p->lc)
   			tstack.push(p->lc);
   	}
   }
   ```

2. 中序

   ```C++
   template<class T>
   void inOrder(BTree<T> tree) {
   	LinkStack<BTree<T>*> tstack;
   	BTree<T>* p= tree.lc;
   	while (p||!tstack.isEmpty()) {
   		if (p) {
   			tstack.push(p);
   			p = p->lc;
   		}
   		else {
   			p = tstack.pop();
   			p->visit();
   			p = p->rc;
   		}
   	}
   }
   ```

3. 后序

   ```C++
   template<class T>
   void postOrder(BTree<T> tree) {
   	LinkStack<BTree<T>*> lstack;
   	LinkStack<BTree<T>*> rstack;
   	BTree<T>* p;
   	lstack.push(tree.lc);
   	while (!lstack.isEmpty()) {
   		p = lstack.pop();
   		rstack.push(p);
   		if (p->lc)
   			lstack.push(p->lc);
   		if (p->rc)
   			lstack.push(p->rc);
   	}
   	while (!rstack.isEmpty()) {
   		p = rstack.pop();
   		p->visit();
   	}
   }
   ```

## 3.4线索二叉树

### 定义

线索：在结点的空指针域中存放指向某次**遍历**得到的**后继或前驱**的指针。

后继线索(右线索)：在空右指针域中存放指向某次遍历得到的后继结点的指针。

前驱线索(左线索)：在空左指针域中存放指向某次遍历得到的前驱结点的指针。

线索二叉树：根据某次遍历, 在二叉树中的相关空指针域都写入线索(后继线索或前驱线索)，即成为线索二叉树。线索二叉树可理解为已经线索化的二叉树。先序后继：先序遍历中得到的后继(先序前驱, 中序后继, 中序前驱, 后序后继, 后序前驱)。

![1665285228852](F:\ProgramData\自动缓存文件\TyporaCache\1665285228852.png)

### 线索化原则

先序后继：将右子树的根结点链入左子树的最后一个叶子结点。

中序后继：给定一个结点x，它是其左子树最后一个叶子结点的后继结点。

后序后继：

（1）若结点x是二叉树的根，则其后继为空；

（2）若结点x是其双亲的右孩子或是其双亲的左孩子且其双亲没有右孩子，则其后继即为双亲结点；

（3）若结点x是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。

### 线索化实现

1. 先序线索化 遍历

   ```C++
   void BTree<T>::preThreading(BTree<T>* B,BTree<T>* &pre) {
   	if (!B || !pre)return;
   
   	//处理根节点
   	//如果当前子树的根节点的左子树为空 就把left指针指向前驱
   	if (B->lc == NULL) {
   		B->lc = pre;
   		B->ltag = 1;
   	}
   	//如果当前子树的根结点的前驱的右子树为空 就把前驱的right指针指向根节点
   	if (pre != NULL && pre->rc == NULL) {
   		pre->rc = B;
   		pre->rtag = 1;
   	}
   
   	pre = B;
   	if (B->ltag == 0)
   		preThreading(B->lc, pre);
   	if (B->rtag == 0)
   		preThreading(B->rc, pre);
   	return;
   }
   
   template<class T>
   void BTree<T>::preOrderTraverse(BTree<T>* B) {
   	if (!B)	return;
   	BTree<T>* p = B;
   	while (p) {
   		while (p->ltag == 0) {
   			p->visit();
   			p = p->lc;
   		}
   		p->visit();
   		p = p->rc;
   	}
   	cout << endl;
   }
   ```

2. 中序线索化 遍历

   ```C++
   template<class T>
   void BTree<T>::inThreading(BTree<T>* B,BTree<T>* &pre)
   {
   	if (!B)return;
   	inThreading(B->lc, pre);
   
   	if (!B->lc) {		//没有左孩子
   		B->ltag = 1;	//修改左标志域
   		B->lc = pre;	//左孩子指向前驱结点
   	}
   
   	if (!pre->rc) {		//没有右孩子
   		pre->rtag = 1;	//修改右标志域
   		pre->rc = B;	//前驱结点右孩子指向当前节点
   	}
   	pre = B;			//保证pre指向下一节点的前驱
   	
   	inThreading(B->rc, pre);
   }
   
   template<class T>
   void BTree<T>::inOrderTraverse(BTree<T>* B) {
   	BTree<T>* p = B;
   	while (p) {
   		while (p->ltag == 0)p = p->lc;
   		p->visit();
   		while (p->rtag == 1) {
   			p = p->rc;
   			p->visit();
   		}
   		p = p->rc;
   	}
   }
   ```

3. 后序线索化 遍历

   ```C++
   template<class T>
   void BTree<T>::postThreading(BTree<T>* B, BTree<T>*& pre) {
   	if (!B)return;
   
   	postThreading(B->lc, pre);
   	postThreading(B->rc, pre);
   
   	if (!B->lc) {
   		B->ltag = 1;
   		B->lc = pre;
   	}
   	if (pre && !pre->rc) {
   		pre->rtag = 1;
   		pre->rc = B;
   	}
   	pre = B;
   }
   
   template<class T>
   void BTree<T>::postOrderTraverse(BTree<T>* B) {
   	if (!B)return;
   	LinkStack<char> stack;
   	BTree<T>* p = B;
   	stack.push(p->data);
   	while (p) {
   		while (p->rtag == 0&&p->rc) {
   			p = p->rc;
   			stack.push(p->data);
   		}
   		while (p->lc&& p->ltag == 1) {
   			p = p->lc;
   			stack.push(p->data);
   		}
   		if (p->rc&&p->lc)
   			continue;
   		p = p->lc;
   	}
   	cout << endl;
   	while (!stack.isEmpty()) {
   		cout << stack.pop();
   	}
   }
   ```

## 3.5哈夫曼树

哈夫曼(Huffman)树又称**最优二叉树**。

![1665459552544](F:\ProgramData\自动缓存文件\TyporaCache\1665459552544.png)

**路径**：从一个结点到另一个结点之间的分支序列，如(a, j)=(a, c)+(c, f)+(f, j) 。

**路径长度**：路径上的分支数，如(a, j)=3。

**树的路径长度**：从**根结点**到**树中每一个叶子结点**的路径长度之**和**。

**结点的权值**：1个具有某种含义的实数。

**带权路径长度**：从根结点到某个(叶子)结点之间的**路径长度**与该**结点的权**的**乘积**。

树的带权路径长度：树中所有叶子结点的带权路径长度之和，记为

 WPL =∑wi li ，i=1, …, n。其中, n表示叶子结点的数目；wi表示第i个叶子结点的**权值**；li 表示从根结点到第i个叶子结点之间的**路径长度**。

![1665461651321](F:\ProgramData\自动缓存文件\TyporaCache\1665461651321.png)

**哈夫曼树**：在n个叶子结点所构造的二叉树中，WPL最小的二叉树。一般不唯一。其中结点的度为0或2。

### 构造最优二叉树的算法

1. 根据给定的n个权值{ w1, w2, …, wn }, 构成n棵二叉树集 T = { T1, T2, …, Tn }，其中，Ti只含1个带权为wi的根结点；
2. 在T中选取两棵根结点的**权值最小**的二叉树Tj和Tk作为左、右子树，构成一棵新的二叉树Tjk , 且置Tjk**根结点的权值**为Tj和Tk根结点的**权值之和**；
3. 从T中删除二叉树Tj和Tk，并将二叉树Tjk添加到T中；  
4. 重复(2)和(3)的操作，直到T中只含有一棵二叉树为止 => 哈夫曼树。  

**例**：按照权值 { 1，2，3，2，2 } 构造一棵哈夫曼树。

![1665546161025](F:\ProgramData\自动缓存文件\TyporaCache\1665546161025.png)

构造说明：

- 在选取结点权值最小的两棵子树时, 如果出现权值相同，可以任选其中一棵子树;
- 两棵结点权值最小的二叉树组成新的二叉树时，没有规定左右子树次序；
- 在哈夫曼树中，权值越大的叶子结点离根结点越近——哈夫曼树的应用依据;
- 具有n个叶子结点的哈夫曼树，共有2n-1个结点(满足二叉树的性质)。
  - 在二叉树中，结点总数为n0+n1+n2，在哈夫曼树中，没有度为1的结点，即哈夫曼树的结点总数为n0+0+n2，根据二叉树性质n0=n2+1，即n2=n0-1=>哈夫曼树的结点总数n0+n2=2n0-1=2n-1。

代码实现：

1. 构造哈夫曼树

   ```C++
   template<typename T>
   MList<HuffmanNode<T>> Huffman(int n) {
   	int i=0,j=0;
   	T e;
   	int weight;
       //由于C++不能直接根据变量名来定义数组，所以这边用了个线性表，实际上用数组的话会更加方便
   	MList<HuffmanNode<T>> hufflist(2 * n - 1);
   
   	for (i = 0; i < n; i++) {
   		cin >> e >> weight;
   		hufflist.elem[i]=HuffmanNode<T>(e, weight);
   	}
   	
   	int min1, min2,locate1,locate2;
   	for (i = n; i < 2*n - 1; i++) {
   		min1 = INT_MAX, min2 = INT_MAX;
   		locate1 = -1; locate2 = -1;
   		for (j = 0; j < i; j++) {
               //挑选最小两个数，左子树比右子树小
   			if (hufflist.elem[j].w <= min1 && hufflist.elem[j].parent == NULL) {
   				min2 = min1;
   				locate2 = locate1;
   				min1 = hufflist.elem[j].w;
   				locate1 = j;
   			}
   			else if (hufflist.elem[j].w <= min2 && hufflist.elem[j].parent == NULL) {
   				min2 = hufflist.elem[j].w;
   				locate2 = j;
   			}
   		}
   		hufflist.elem[locate1].parent = i;
   		hufflist.elem[locate2].parent = i;
   		hufflist.elem[i]=HuffmanNode<T>('A'+i, hufflist.elem[locate1].w + hufflist.elem[locate2].w, locate1, locate2);
   	}
   
   	for (i = 0; i < 2 * n - 1; i++) {
   		cout << i << ":\t";
   		hufflist.elem[i].toString();
   	}
   	return hufflist;
   }
   ```

2. 输出哈夫曼编码

   ```C++
   template<typename T>
   void Huffcode(MList<HuffmanNode<T>> hufflist,int n) {
   	stack<char> code;
   	int i, j;
   	for (i = 0; i < n; i++) {
   		j = i;
   		while (hufflist.elem[j].parent != NULL) {
   			if (hufflist.elem[hufflist.elem[j].parent].lc == j)code.push('0');
   			else code.push('1');
   			j = hufflist.elem[j].parent;
   		}
   		cout << i << ":" << hufflist.elem[i].data << "\t";
   		while (!code.empty()) {
   			cout << code.top();
   			code.pop();
   		}
   		cout << endl;
   	}
   }
   ```

## 3.6树的存储结构

### 树的双亲表示法

用顺序表存储树的结点，每个结点包含数据域和指针域(双亲位置)。 

也称为**树的静态链表**结构，它是以一组地址连续的存储空间存放树的结点，每个结点中包含**数据域**和**整型指针域**。  

![1665718758016](F:\ProgramData\自动缓存文件\TyporaCache\1665718758016.png)

```C++
//树的双亲表示法
template<class T>
class TNode {
public:
	T data;  //数据元素
	int parent;//双亲位置
}; //结点结构

//树的存储结构
template<class T>
class PTree {
public:
	int length;
	TNode<T> tree[100];
	int nodenum;//结点数

	PTree();
};

template<class T>
PTree<T>::PTree() {
	this->length = 100;
	this->nodenum = 0;
}
```

### 树的孩子表示法

每个结点建立1个链表，用于存储该结点的所有孩子结点。

每个结点建立一个链表，该链表由它的**孩子结点**构成。其中，**叶子结点产生空链表**。

在链表中, **孩子域(即数据域)**存放孩子结点在**顺序表**中的**位置**(下标)。

由**n个结点的元素值**和**指向孩子链表的头指针**再构成1个**线性表**(顺序存储结构)。

![1665719936030](F:\ProgramData\自动缓存文件\TyporaCache\1665719936030.png)

```C++

template<class T>
class CNode {
public:
	int child; // 孩子结点在顺序表中的位置
	CNode<T>* next;
};//孩子链表结构

template<class T>
class Tchild{
public:
	T data;
	CNode<T>  firstchild;//孩子链表头指针

	Tchild(T e) {
		this->data = e;
		this->firstchild = new CNode<T>;
	}
	~Tchild() {
		delete this->firstchild;
	}
};//表头指针结构

template<class T>
class CTree
{
public:
	Tchild<T>  T[100];
	int  r, n;//根的位置，结点数

	CTree() { r = 0; n = 0; }
};//树的存储结构
```



### 树的孩子兄弟表示法

用二叉树的存储结构表示树，第1个孩子为左孩子，其它兄弟依次存储为右孩子。也称为**树的二叉链表存储结构**  

```C++
//树的孩子兄弟表示法
template<class T>
class Tnode
{
	T data;//数据元素域
	struct Tnode* Child1;//第1个孩子
	struct Tnode* Sibling;//下1个兄弟
};
```

![1665720959313](F:\ProgramData\自动缓存文件\TyporaCache\1665720959313.png)

## 3.7**森林与二叉树的转换**

由于二叉树和树都可用**二叉链表**作为存储结构，对比各自的结点结构可以看出，以二叉链表作为媒介可以导出树和二叉树之间的一个对应关系。

- 从**物理结构**来看，树和二叉树的二叉链表是相同的，只是对指针的逻辑解释不同而已。

- 从树的**二叉链表**表示的**定义**可知，任何一棵和树对应的二叉树，其**右子树一定为空。**

下图直观地展示了树和二叉树之间的对应关系。

![1665799148316](F:\ProgramData\自动缓存文件\TyporaCache\1665799148316.png)

### 树转换成二叉树

对于一般的树，可以方便地转换成一棵唯一的二叉树与之对应。将树转换成二叉树在“孩子兄弟表示法”中已给出，其详细步骤是：

1. 加虚线。在树的每层按从“左至右”的顺序在兄弟结点之间加虚线相连。
2. 去连线。除最左的第一个子结点外，父结点与所有其它子结点的连线都去掉。
3. 旋转。将树顺时针旋转450，原有的实线左斜。
4. 整型。将旋转后树中的所有虚线改为实线，并向右斜。该转换过程如下图所示。

这样转换后的二叉树的特点是：

- 二叉树的**根结点没有右子树**，只有左子树；

- 左子结点仍然是原来树中相应结点的左子结点，而所有**沿右链往下的右子结点均是原来树中该结点的兄弟结点**。

![1665799668995](F:\ProgramData\自动缓存文件\TyporaCache\1665799668995.png)



### 二叉树转换成树

对于一棵转换后的二叉树，如何还原成原来的树。步骤是：

1. 加虚线。若某结点i是其**父结点的左子树的根结点**，则将该结点i的右子结点以及沿右子链不断地搜索**所有的右子结点**，将所有这些**右子结点**与**i结点的父结点**之间加虚线相连，如下图(a)所示。
2. 去连线。去掉二叉树中**所有父结点与其右子结点之间的连线**，如下图(b)所示。
3. 规整化。将图中各结点**按层次排列**且将所有的**虚线变成实线**，如下图(c)所示。

![1665799830553](F:\ProgramData\自动缓存文件\TyporaCache\1665799830553.png)

### 森林转化为二叉树

当一般的树转换成二叉树后，二叉树的右子树必为空。若把森林中的**第二棵树**(转换成二叉树后)的**根结点**作为**第一棵树(二叉树)的根结点的兄弟结点**，则可导出森林转换成二叉树的转换算法如下：

设F={T1, T2,⋯,Tn}是森林，则按以下规则可转换成一棵二叉树B=(root，LB，RB)

1. 若n=0，则B是空树。
2. 若n>0，则二叉树B的根是森林T1的根root(T1)，B的左子树LB是B(T11,T12, ⋯,T1m) ，其中T11,T12, ⋯,T1m是T1的子树(转换后)，而其右子树RB是从森林F’={T2, T3,⋯,Tn}转换而成的二叉树。

**转换步骤**： 

①  将F={T1, T2,⋯,Tn} 中的每棵树转换成二叉树。

② 按给出的森林中树的次序，从最后一棵二叉树开始，每棵二叉树作为前一棵二叉树的根结点的右子树，依次类推，则第一棵树的根结点就是转换后生成的二叉树的根结点，如下图所示。

![1665800095762](F:\ProgramData\自动缓存文件\TyporaCache\1665800095762.png)

### 二叉树转化为森林

若B=(root，LB，RB)是一棵二叉树，则可以将其转换成由若干棵树构成的森林：F={T1, T2,⋯,Tn} 。

转换算法：

1. 若B是空树，则F为空。
2. 若B非空，则F中第一棵树T1的根root(T1)就是二叉树的根root， T1中根结点的子森林F1是由树B的左子树LB转换而成的森林；F中除T1外其余树组成的森林F’={T2, T3,⋯,Tn} 是由B右子树RB转换得到的森林。

上述转换规则是递归的，可以写出其递归算法。以下给出具体的还原步骤。

1. 去连线。将二叉树B的根结点与其右子结点以及沿右子结点链方向的所有右子结点的连线全部去掉，得到若干棵孤立的二叉树，每一棵就是原来森林F中的树依次对应的二叉树，如下图(b)所示。
2. 二叉树的还原。将各棵孤立的二叉树按二叉树还原为树的方法还原成一般的树，如下图(c)所示。

![1665800265748](F:\ProgramData\自动缓存文件\TyporaCache\1665800265748.png)

## 3.8树的应用

### 树的先根遍历

```C++
template<class T>
void CSnode<T>::preTree(){
	if (!this)return;
	cout << this->data;
	preTree(this->Child1);
	preTree(this->Sibling);
}
```

### 树的后根遍历

```C++
template<class T>
void CSnode<T>::postTree() {
	if (!this)return;
	preTree(this->Child1);
	preTree(this->Sibling);
	cout << this->data;
}
```

### 树的层序遍历

```C++
template<class T>
void CSnode<T>::levelTree(CSnode<T> &head) {
	CSnode<T>* p = &head;
	queue<CSnode<T>*> tqueue;
	while (p||!tqueue.empty()) {
		if (!p && !tqueue.empty()) { 
			p = tqueue.front(); tqueue.pop(); }
		p->visit();
		cout << " ";
		if (p->Child1)tqueue.push(p->Child1);
		p = p->Sibling;
	}
}
```

### 例题

1. 编写递归算法：对于二叉树中每一个元素值为x的结点，删去以它为根的子树，并释放相应的空间。

   ```C++
   template<class T>
   void BTree<T>::deleteCTree(T e){
   	if (!this)return;
   	if (this->data == e)this->deleteCTree();
   	else {
   		this->lc->deleteCTree(e);
   		this->rc->deleteCTree(e);
   	}
   }
   
   template<class T>
   void BTree<T>::deleteCTree(){
   	if (!this)return;
   	BTree<T>* p = this;
   	p->lc->deleteCTree();
   	p->rc->deleteCTree();
   	p->~BTree();
   }
   ```

2. 判断二叉树是否相似。

    二叉树的相似，是指俩二叉树有**相似的结构**，同样的节点位置可以有不同的值，但要么都是空节点，要么都不是空节点。只要有一个节点位置不相似，即一个是空节点，另一个是非空节点，则整个二叉树都不相似。 

   ```C++
   template<class T>
   bool BTree<T>::likeTree(BTree<T>* A, BTree<T>* B) {
   	if (!A && !B)return true;
   	if (!A || !B)return false;
   	int l, r;
   	l = likeTree(A->lc, B->lc);
   	r = likeTree(A->rc, B->rc);
   	return (l && r);
   }
   ```

3. 求二叉链表T中值为x的数据元素所在的层次。

   ```C++
   template<class T>
   int BTree<T>::BTL(T e) {
   	if (!this) return 0;
   	if (this->data == e)return 1;
   	int lk, rk;
   	lk = this->lc->BTL(e);
   	rk = this->rc->BTL(e);
   	if (!lk && !rk)return 0;
   	else return lk > rk ? lk+1 : rk+1;
   }
   ```

   



